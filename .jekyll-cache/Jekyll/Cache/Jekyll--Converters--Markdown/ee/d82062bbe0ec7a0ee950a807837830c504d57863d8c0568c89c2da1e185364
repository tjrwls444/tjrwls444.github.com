I"“<h3 id="7-ì •ë ¬--í™ì •ë ¬í¸">7. ì •ë ¬ : í™ì •ë ¬í¸</h3>
<ul>
  <li>Max Heap í˜¹ì€ Min Heapì„ í†µí•´ ì •ë ¬í•˜ëŠ” ë°©ë²•</li>
</ul>

<p class="bold-text"> i) ê³¼ì •</p>
<ul>
  <li>inputë°ì´í„°ë¥¼ Heapìœ¼ë¡œ êµ¬ì„±í•˜ê¸°</li>
  <li>ì œê±°ë¥¼ í†µí•´ í•˜ë‚˜ì”© ë¹¼ê¸°
<a href="/datastructure/java/2019/10/26/data-structure-heap.html" target="_blank">ìë£Œêµ¬ì¡° Heapí¸ ì°¸ê³ </a></li>
</ul>

<p class="bold-text"> ii) ì¥ì  </p>
<ul>
  <li>ë¹ ë¥´ë‹¤ O(nlogN)</li>
</ul>

<p class="bold-text"> iii) ë‹¨ì  </p>
<ul>
  <li>O(nlogN)ì´ì§€ë§Œ ì‹¤ì œ ì¸¡ì •í•˜ë©´ ë‹¤ë¥¸ ì •ë ¬ë²•ë“¤ì— ë¹„í•´ ì¡°ê¸ˆ ëŠë¦¬ë‹¤.</li>
</ul>

<p class="bold-text"> vi) ì‹œê°„ë³µì¡ë„</p>
<ul>
  <li>nlogN</li>
</ul>

<pre>
class HeapSort {
    private int [] heap;
    private int [] data;
    private int maxSize;
    private int inputSize;
    private int pointer;
   
    // Heapê³µê°„ í™•ë³´
    public HeapSort( int[] data ){
        maxSize = 1;
        this.data = data;
        inputSize = data.length;
        while( maxSize &lt;= inputSize )
            maxSize &lt;&lt;= 1;
        
        this.heap = new int[maxSize];
    }
    // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ 1 2 3 4 5
    public void ascendingSrot() {
        //MaxHeapìœ¼ë¡œ êµ¬ì„± : 1
        makeHeap( 1 );
        for (int index = 0; index &lt; inputSize; index++) {
            data[index] = remove(1);
        }
    }
    
    public void descendingSrot() {
        // MinHeapìœ¼ë¡œ êµ¬ì„± : 0
        makeHeap( 0 );
        for (int index = 0; index &lt; inputSize; index++) {
            data[index] = remove(0);
        }
    }
    
    // 1ì´ë©´ MaxHeap , 0ì´ë©´ MinHeap
    public void makeHeap( int position ) {
        pointer = 0;
        // ë§ˆì§€ë§‰ ë…¸ë“œì— ê°’ ë¶™ì´ê¸° 
        if(isFull()) {
            throw new ArrayIndexOutOfBoundsException();
        }
        for (int index = 0; index &lt; inputSize; index++) {
            int tempIndex   = ++pointer;
            // ë§ˆì§€ë§‰ë…¸ë“œì— ê°’ ë„£ê¸°
            int item        = data[index];
            heap[pointer]   = item;
            
            // ë¶€ëª¨ì™€ ë¹„êµ ë¡œì§
            
            while( tempIndex &gt; 0 &amp;&amp; tempIndex != 1) {
                int parentValue = heap[tempIndex/2];
                Boolean sortCheck  = position == 1 ? parentValue &lt; item : parentValue &gt; item;
                if( sortCheck ) {
                    // êµí™˜
                    int swapData = parentValue;
                    heap[tempIndex/2] = item;
                    heap[tempIndex] = swapData;
                } else {
                    break;
                }
                tempIndex /= 2;
            }
        }
    }
    
    // 1ì¼ë•Œ Maxí™ ì¤„ì´ê¸° , 0ì¼ë•Œ MinHeap ì¤„ì´ê¸°
    public int remove( int position ) {
        if(isEmpty()) {
            throw new ArrayIndexOutOfBoundsException();
        }
        // rootì™€ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ ë³€ê²½ í›„ pointì‚¬ì´ì¦ˆë¥¼ í•˜ë‚˜ ì¤„ì„
        int result      = heap[1];
        int lastChild   = heap[pointer];
        heap[1]         = lastChild;
        heap[pointer--] = 0;
        
        // ìì‹ë“¤ ë¹„êµí™•ì¸ ë¡œì§ ìì‹ë“¤ ë…¸ë“œ ì¤‘ ê°’ì´ ë” í° ë…¸ë“œì™€ êµì²´í•œë‹¤.
        int tempIndex   = 1;
        while( tempIndex*2 &lt;= pointer ) {
            Boolean hasRightChild = tempIndex*2+1 &lt;= pointer;
            int leftChild  = heap[tempIndex*2];
            int rightChild = heap[tempIndex*2+1];
            int parent     = heap[tempIndex];
            int changeValue;
            int changeIndex;
            
            Boolean sortCheck;
            
            if( !hasRightChild ) {
                sortCheck = position == 1 ? parent &gt; leftChild : parent &lt; leftChild;
                
                if( sortCheck ) break;
                
                changeIndex = tempIndex*2;
                changeValue = leftChild;
            } else {
                sortCheck = position == 1 ? parent &gt; leftChild &amp;&amp; parent &gt; rightChild  : parent &lt; leftChild &amp;&amp; parent &lt; rightChild;
                
                if( sortCheck ) break;
                sortCheck = position == 1 ? leftChild &lt; rightChild : leftChild &gt; rightChild;
                
                changeValue = sortCheck ? rightChild : leftChild;
                changeIndex = sortCheck ? tempIndex*2+1 : tempIndex*2;
                
            }
            
            //êµì²´
            heap[tempIndex]    = changeValue;
            heap[changeIndex]  = parent;
            tempIndex = changeIndex;
            
        }
        
        return result;
    }
    
    public void print() {
        StringBuilder result = new StringBuilder();
        for (int i : data) {
            result.append(i + " ");
        }
        System.out.println(result.toString());
    }
    
    public Boolean isEmpty() {
        //ì‹œê°„ ë³µì¡ë„ O(1)
        return pointer == 0;
    }
    public Boolean isFull() {
        //ì‹œê°„ ë³µì¡ë„ O(1)
        return pointer &gt;= maxSize;
    }
}

**ì‚¬ìš©í•˜ê¸°
int[] data = {254,3,213,64,75,56,4,324,65,78,9,5,76,3410,8,342,76};
ShellSort HeapSort = new HeapSort(data);

sortData.ascendingSrot();
sortData.print();

sortData.descendingSrot();
sortData.print();
</pre>
:ET